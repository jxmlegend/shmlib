# shmlib
1、本实例以实际应用为目的，实现了循环队列形式的进程间共享内存机制。该机制可以快速实现数据的先入先出，方便控制内存的大小，减少数据的拷贝次数。
    实现的原理非常简单，首先创建指定大小的共享内存，其中前面的几个int变量定义为内存的信息区，后面为实际的数据区。写进程会初始化共享内存的信息区，而读进程会根据这些信息来读取数据块中的数据。
    ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
    ▏块大小 ▏总块数 ▏读索引 ▏写索引 ▏内存是否存在标志 ▏退出标志 ▏▪▪▪保留位••• ▏数据块 ▏数据块 ▏▪▪▪•• ▏数据块 ▏数据块 ▏
    ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔
    填入信息之后，写进程一有数据需要写入，便去数据区找到紧挨着的一块还没写入数据的数据块（这里以数据块结构中的flag为0表示还没有写入数据进行写入，把flag标志位置1然后把指针移动到下一位。直到内存被写满为止，也就是下一位数据块中的falg标志位1。读进程则看到自己指针所指的数据块的标志位为1则去读取数据，读取完成后把glag标志位置0然后移动到下一位。移动到数据区末尾的时候则回到数据区的开头即可。

2、为什么gcc调用g++编译的动态库正常，而调用同一个文件编译的静态库就报错？为什么gcc使用g++静态库编译报错，需要加-lstdc++才行？
	ldd libshmobject.so，会发现libshmobject.so依赖一些库（g++编译libshmobject.so的时候会自动链接的），其中包括libstdc++库。
	(a)动态库会自动链接一些依赖库。
	(b)静态库只是一堆.o文件的集合，没有那么智能，需要手工解决依赖库。此处gcc使用g++编译的静态库时，需要添加-lstdc++(链接libstdc++库)。

3、gcc使用g++编译的库的原则
	(a)g++编译库的时候需要把被外界使用的接口按照纯C++可以接受的方式用extern "C" 包起来,并且加上__cplusplus宏的判断。
	(b)对于一些特殊情况,比如已经是g++编译出来的库又不适合修改,比如ullib, 分词库等第三方库,可以自己写一个 xxx.cpp的程序,在xxx.cpp对需要使用的接口再做一次纯C接口的封装,同时用extern "C"把纯C接口导出使用.使用g++编译,并且在链接的时候加上ullib等库即可。
	(c)gcc使用g++静态库编译报错，需要加-lstdc++才行。

4、g++使用gcc编译的库的原则
	这个比较简单,只需要gcc编译的提供的头文件采用extern "C"封装即可

